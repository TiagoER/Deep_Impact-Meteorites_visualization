<!--
	minimapa
	coordenadas do utilizador
-->
<html>
<head>
    <title>
        Information Visualization
    </title>
    <style>

        body {
            margin: 0px;
            padding: 0px;
            overflow:hidden;
            background: white;
            
        }

        img .on,
        img .off {
            height: 20px;
            width: 0.2vw;
        }

        img .on {
            opacity: 1;
        }

        img .off {
            opacity: 0.2;
        }

        .searchBlur {
            background: rgba(255,255,255,0.8) url(mag.png) 4px 5px no-repeat;
        }

        .searchResultCity,
        .searchResultMeteo {
            font-size: 16pt;
            overflow: hidden;
            border: 1px solid white;
            border-width: 0px 0px 1px 0px;
            white-space: nowrap;
            text-overflow:ellipsis;
            
            padding: 4px 10px;
            font-family: sans-serif;
            text-align: left;
        }

        .searchResultCity {
            color: #999999;
        }

        .searchResultMeteo {
            background: rgba(128,128,128,0.9);
            color: #804040;
        }

        .and {
            font-style:italic;
            color: #808080;
            text-align: right;
            padding: 4px;
        }

        /* D3 */
    
        svg {
            font: 10px sans-serif;
        }

        .area {
            fill: rgba(255,165,0,0.2);
            stroke-width: 1pt;
            stroke: orange;
            clip-path: url(#clip);
        }

        .focus .area {
            fill: #ccc /*rgba(128,128,128,0.5)*/;
            stroke-width: 1pt;
            stroke: #666;
            clip-path: url(#clip);
        }

        .axis path,
        .axis line {
            fill: none;
            stroke: black;
            shape-rendering: crispEdges;
            line-height: 1px;
            
        }
        .axis path {
            /*display:none*/
        }

        .axis .minor line {
            stroke: #777;
            stroke-dasharray: 2, 2;
        }
        .axis .minor path {
            display:none;
        }

        .focus .axis text {
            font-size: 18pt;
            fill: black;
        }

        .context .axis text {
            font-size: 18pt;
            fill: #fff;
        }

        .context .axis line {
            stroke: #444;
            //stroke-dasharray: 2, 2;
        }

        .context .axis path {
            display:none;
        }

        .context g:nth-child(1) text {
            /* fill:white; */
        }
        
         .brush .extent {
            stroke: #fff;
            fill: steelblue;
            fill-opacity: .25;
            shape-rendering: crispEdges;
            clip-path: url(#clip);
        }

        rect.pane {
            cursor: move;
            fill: none;
            pointer-events: all;
        }

        /* map */

        .background {
            fill: none;
            pointer-events: all;
        }

        .feature {
            fill: #ccc;
            cursor: pointer;
        }

        .feature.active {
                fill: orange;
            }

        .mesh {
            fill: none;
            stroke: #fff;
            stroke-linecap: round;
            stroke-linejoin: round;
        }

        .parallelCanvas, #parallelSVG {
            position: absolute;
            top: 0;
            left: 0;
        }

        #parallelChart .brush .extent {
            fill: steelblue;
            fill-opacity: .5;
            stroke: #fff;
            shape-rendering: crispEdges;
        }

        #parallelChart .axis path {
            fill: none;
            stroke: #fff;
            stroke-dasharray: 2, 2;
            shape-rendering: crispEdges;
        }

        #parallelChart .axis line {
            stroke: none;
        }

        #parallelChart .axis text {
            fill: #fff;
            font-size: 1vw;
        }

        #parallelChart .axis g text {
            fill: white;
            font-size: 12px;
            opacity: 1;
            text-shadow: 1px 1px 0 black, -1px 1px 0 black, 1px -1px 0 black, -1px -1px 0 black;
        }

        #UISwitches {
            background: rgba(18,18,18,0.95);
        }

        /* TOOLTIP */

        .d3-tip {
            position:absolute;
            font-weight: bold;
			font-family: sans-serif;
            padding: 12px;
            background: rgba(0, 0, 0, 0.95);
            color: #fff;
            border-radius: 20px;
            z-index:200;
        }

        /* Creates a small triangle extender for the tooltip */
        /*
        div.d3-tip:after {
            box-sizing: border-box;
            display: inline;
            top:100%;
            left:0;
            font-size: 14px;
            width: 100%;
            line-height: 1;
            color: rgba(0, 0, 0, 0.8);
            content: "\25BC";
            position: absolute;
            text-align: center;
            margin-top:-1px;
        }
            */

        .histogram path,
        .histogram line {
            fill: none;
            stroke: #999;
            stroke-dasharray: 2, 2;
            shape-rendering: crispEdges;
            line-height: 1px;
        }

        .histogram path {
            stroke: none;
        }
		
		#smallMultiples::-webkit-scrollbar {
		  width: 6px;
		  height: 6px;
		}
		#smallMultiples::-webkit-scrollbar-button {
		  width: 0px;
		  height: 0px;
		}
		#smallMultiples::-webkit-scrollbar-thumb {
		  background: #e1e1e1;
		  border: 1px solid #ffffff;
		  border-radius: 50px;
		}
		#smallMultiples::-webkit-scrollbar-thumb:hover {
		  background: #ffffff;
		}
		#smallMultiples::-webkit-scrollbar-thumb:active {
		  background: #000000;
		}
		#smallMultiples::-webkit-scrollbar-track {
		  background: #666666;
		  border: 0px none #ffffff;
		  border-radius: 0px;
		}
		#smallMultiples::-webkit-scrollbar-track:hover {
		  background: #666666;
		}
		#smallMultiples::-webkit-scrollbar-track:active {
		  background: #333333;
		}
		#smallMultiples::-webkit-scrollbar-corner {
		  background: transparent;
		}

    </style >
    <script src="d3.min.js"></script>
    <script src="queue.v1.min.js"></script>
    <script src="colorbrewer.min.js"></script>
    <script src="d3.hexbin.min.js"></script>
    <script src="http_d3js.org_topojson.v1.js"></script>
    <script>
	
        var tipTimeout;

        function formatMass(d) {
            str = "";
            if (d > 999999) { str = (Math.floor(d / 10000) / 100) + "t" }
            else {
                if (d > 999) { str = (Math.floor(d / 10) / 100) + "kg" }
                else { str = d.toFixed(2) + "g" }
            }
            return str
        }

        function gradientBackground(elementId, percentage, color) {
            
            if (typeof percentage.length === "undefined") {
                var rounded = Math.floor(percentage * 100)
                window.document.getElementById(elementId + "C").style.background =
                    "linear-gradient(to right, #CFB172 " + rounded + "%, rgb(36, 36, 36) " + rounded + "%)"
            } else {
                var rounded1 = Math.floor(percentage[0] * 100)
                var rounded2 = Math.floor(percentage[1] * 100)
                window.document.getElementById(elementId + "C").style.background =
                    "linear-gradient(to right, #826f48 " + rounded1 + "%, #CFB172 " + rounded1 + "%, #CFB172 " + rounded2 + "%, rgb(36, 36, 36) " + rounded2 + "%)"
            }
            window.document.getElementById(elementId).style.color= "white";
            window.document.getElementById(elementId).style.textAlign = "left";
            window.document.getElementById(elementId).style.padding = "4px";
                
        }

        function hexTip(gi, gj) {

            var tr = mapCurrentTranslation;
            var dataset = mapHexbin(meteoFilter.data.filter(function (d) { return d.latitude > latmin && d.latitude < latmax; })).filter(function (d) { return d.i == gi && d.j == gj });
            tip(dataset[0]);
        }

        function tip(dataset) {

            if (dataset.length == 0) { return; }

            if (dataset.length == 1) {
                window.document.getElementById("metName").innerText = dataset[0].name;

                window.document.getElementById("metYear").innerHTML = "<span style=\"color:#ccc\">found in</span> <span style=font-size:12pt>" + dataset[0].year + "</span>";
                gradientBackground("metYear", (dataset[0].year - 1887) / 128)

                window.document.getElementById("metMass").innerHTML = "<span style=\"color:#ccc\">weighs</span>  <span style=font-size:12pt>" + formatMass(dataset[0].mass) + "</span>";
                gradientBackground("metMass", 1 - parallelY["mass"](dataset[0].mass) / parallelY["mass"].range()[0])

                if (Math.ceil(dataset[0].cost) > 0)
                    window.document.getElementById("metCost").innerHTML = "<span style=\"color:#ccc;font-size:12pt\">worth </span> <span style=font-size:12pt;color:orange>$" + Math.ceil(dataset[0].cost) + "</span>";
                else
                    window.document.getElementById("metCost").innerHTML = "<span style=font-size:12pt;color:#606060>No estimated value</span>";

                if (dataset[0].elevation >= 0)
                    window.document.getElementById("metElevation").innerHTML = "<span style=font-size:12pt>" + dataset[0].elevation + "m</span> <span style=\"color:#ccc\">above sea level</span>";
                else
                    window.document.getElementById("metElevation").innerHTML = "<span style=font-size:12pt>" + dataset[0].elevation + "m</span> <span style=\"color:#ccc\">below sea level</span>";
                gradientBackground("metElevation", 1 - parallelY["elevation"](dataset[0].elevation) / parallelY["elevation"].range()[0])

            } else {

                window.document.getElementById("metName").innerHTML = "<span style=color:orange>" + dataset.length + "</span> meteorites";

                var years = dataset.map(function (d) { return d.year })
                var yearspan = [Math.min.apply(null, years), Math.max.apply(null, years)]

                if (yearspan[0] == yearspan[1]) {
                    window.document.getElementById("metYear").innerHTML = "<span style=\"color:#ccc\">found in</span> <span style=font-size:12pt>" + yearspan[0] + "</span>";
                    gradientBackground("metYear", yearspan[0])
                } else {
                    window.document.getElementById("metYear").innerHTML = "<span style=\"color:#ccc\">found in</span> <span style=font-size:12pt>" + yearspan[0] + "</span> <span style=\"color:#ccc\">to</span>  <span style=font-size:12pt>" + yearspan[1] + "</span>";
                    gradientBackground("metYear", [(yearspan[0] - 1887) / 128, (yearspan[1] - 1887) / 128])
                }

                var masses = dataset.map(function (d) { return d.mass })
                var massspan = [Math.min.apply(null, masses), Math.max.apply(null, masses)]
                var masstotal = masses.reduce(function (a, b) { return a + b; });

                window.document.getElementById("metMass").innerHTML = "<span style=\"color:#ccc\">weighing</span>  <span style=font-size:12pt>" + formatMass(masstotal) + "</span>";
                gradientBackground("metMass", [(1 - parallelY["mass"](massspan[0]) / parallelY["mass"].range()[0]), (1 - parallelY["mass"](massspan[1]) / parallelY["mass"].range()[0])])

                var costs = dataset.map(function (d) { return d.cost })
                var costtotal = costs.reduce(function (a, b) { return a + b; });

                if (Math.ceil(dataset[0].cost) > 0)
                    window.document.getElementById("metCost").innerHTML = "<span style=\"color:#ccc;font-size:12pt\">worth </span> <span style=font-size:12pt;color:orange>$" + Math.ceil(costtotal) + "</span>";
                else
                    window.document.getElementById("metCost").innerHTML = "<span style=font-size:12pt;color:#606060>No estimated value</span>";

                var elevations = dataset.map(function (d) { return d.elevation })
                var elevationspan = [Math.min.apply(null, elevations), Math.max.apply(null, elevations)]

                window.document.getElementById("metElevation").innerHTML = "<span style=font-size:12pt>" + elevationspan[0] + "m</span> <span style=\"color:#ccc\">to </span> <span style=font-size:12pt>" + elevationspan[1] + "m</span>";
                gradientBackground("metElevation", [(1 - parallelY["elevation"](elevationspan[0]) / parallelY["elevation"].range()[0]), (1 - parallelY["elevation"](elevationspan[1]) / parallelY["elevation"].range()[0])])

            }

            starChartRedraw(dataset);
            backupParallel();
            parallelRedraw(dataset);
        }

    </script>
    <script>

        
        function isEmpty(str) {
            return str.replace(/^\s+|\s+$/g, '').length == 0;
        }

        function searchFocus() {
            event.target.classList.remove("searchBlur");
        }

        function searchBlur() {
            if (isEmpty(window.document.getElementById("search").value))
                window.document.getElementById("search").classList.add("searchBlur");
        }

		var isExpanded = false;
		
		function mapResize(){
			if (isExpanded) contract()
			else expand()
		}
		
		function expand(){
			window.document.getElementById("hideShowButton").innerHTML = "<img src=\"up.svg\" height=\"20\" width=\"20\" valign=\"middle\"> Show"
			d3.select("#UISwitches").transition().duration(250).style("bottom","-260px")
			d3.select("#chart").transition().duration(250).style("bottom","0px")
			d3.select("#parallelChart").transition().duration(250).style("bottom","-260px")
			d3.select("#smallMultiples").transition().duration(250).style("bottom","-260px")
			d3.select("#filterLabel").transition().duration(250).style("bottom","110px")
			//d3.select("#countryLabel").transition().duration(250).style("top",window.innerHeight - window.document.getElementById("chart").offsetHeight)
			isExpanded = true;
		}

		function contract(){
			window.document.getElementById("hideShowButton").innerHTML = "<img src=\"down.svg\" height=\"20\" width=\"20\" valign=\"middle\"> Hide"
			d3.select("#UISwitches").transition().duration(250).style("bottom","0px")
			d3.select("#chart").transition().duration(250).style("bottom","265px")
			d3.select("#parallelChart").transition().duration(250).style("bottom","0px")
			d3.select("#smallMultiples").transition().duration(250).style("bottom","0px")
			d3.select("#filterLabel").transition().duration(250).style("bottom","373px")
			//d3.select("#countryLabel").transition().duration(250).style("top",window.innerHeight - window.document.getElementById("chart").offsetHeight - 265)
			isExpanded = false;
		}
		
    </script>
</head>
<body>
    <!-- TIMELINE -->
    <div id="chart" style="position: absolute; bottom: 0px; height: 70px; padding: 4px 0px; background: rgba(18,18,18,0.95); z-index: 3; text-align: right">
		<div id="hideShowButton" style="position: absolute; width: 80px; text-align: left; bottom: calc(100% + 1px); padding: 8px 20px; right: 0px; background:rgba(18,18,18,0.95); border-radius: 10px 0px 0px 0px; font-size: 18px; color: white; text-shadow: 1px 1px 2px #303030, -1px 1px 2px #303030, -1px 1px 2px #303030, -1px -1px 2px #303030; font-weight: bold; font-family: sans-serif" onclick="mapResize()"><img src="down.svg" height="20" width="20" valign="middle"> Hide</div>
		<div id="countryLabel" style="position: absolute; left: 0px; font-size: 8vh; font-family: sans-serif; padding-left: 10px; color: white; -webkit-text-stroke: 0vw rgba(0,0,0,0.5); text-shadow: 3px 3px 0 #000, -1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000, 1px 1px 0 #000; -webkit-touch-callout: none; -webkit-user-select: none; -khtml-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; z-index: 100; "></div>
    </div>
    <div id="filterLabel" style="position: absolute; display:none; left: 0px; font-size: 8vh; font-family: sans-serif; padding-left: 10px; color: rgba(18,18,18,0.95); -webkit-text-stroke: 0vw rgba(255,255,255,0.5); text-shadow: 3px 3px 0 #fff, -1px -1px 0 #fff, 1px -1px 0 #fff, -1px 1px 0 #fff, 1px 1px 0 #fff; -webkit-touch-callout: none; -webkit-user-select: none; -khtml-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; z-index: 100;">Total Impacts on</div>
    <div id="chart2" style="position: absolute; display:none; bottom: 70px; left: 10px; width: 240px; height: 220px; padding: 4px 4px; border: 4px solid #606060; border-radius: 10px; background: rgba(255,255,255,0.95); overflow: hidden; z-index: 3; box-shadow: rgba(0,0,0,0.2) 2px 2px; "></div>
    <div id="visbar" style="position: absolute; bottom: 0px; height: 70px; padding: 4px 0px; background: #101010; z-index: 3; display:none">
    </div>
    <div id="sample" style="display:none; position: absolute; bottom: 240px; left: 10px; width: 200px; padding: 10px; background: rgba(18,18,18,0.95); font-size: 16pt; color: white; font-family: sans-serif; z-index: 102; ">
        Mass
        <div style="position: absolute; top: 100%; width: 220px; left: 0px; overflow: hidden; background: darkgreen; height: 5px; padding: 0px; border-bottom: 1px solid rgba(18,18,18,0.95)">
            <div style="width: 70%; margin-left: 10%; border-left: 1px solid rgba(0,0,0,0.5); background: rgba(255,255,255,0.3); height: 100%; overflow: hidden"></div>
        </div>
    </div>

    <div id="sample2" style=" display:none; position: absolute; bottom: 240px; left: 231px; width: 200px; padding: 10px; background: rgba(18,18,18,0.95); font-size: 16pt; color: white; font-family: sans-serif; z-index: 102; ">
        Elevation
        <div style="position: absolute; top: 100%; width: 220px; left: 0px; overflow: hidden; background: darkred; height: 5px; padding: 0px; border-bottom: 1px solid rgba(18,18,18,0.95)">
            <div style="width: 20%; margin-left: 50%; border-left: 1px solid rgba(0,0,0,0.5); background: rgba(255,255,255,0.3); height: 100%; overflow: hidden"></div>
        </div>
    </div>

    <div id="parallelChart" style="position:absolute; z-index:4; right: 0px; height: 260px; bottom: 0px; background: rgba(18,18,18,0.95); width: calc(100% - 305px);">
        <canvas class="parallelCanvas" id="parallelBackground"></canvas>
        <canvas class="parallelCanvas" id="parallelForeground"></canvas>
        <svg class="parallelSVG" id="parallelSVG"></svg>
    </div>

    <div id="smallMultiples" style="box-sizing: border-box; position:absolute; width: calc(100% - 305px); left: 305px; z-index:4; bottom: 0px; background: rgba(18,18,18,0.95); display:none; overflow-x: scroll; white-space: nowrap;">
        <div id="elevationChart" style="padding: 10px 0px 10px 40px; left: 0%; width: 150; text-align: center; display: inline-block">
            <div style="font-size: 18pt; color: white; font-family: sans-serif; margin: 10px">elevation</div>
        </div>
        <div id="faChart" style="padding: 10px 0px 10px 40px; left: 20%; width: 150; text-align: center; display: inline-block">
				<div style="font-size: 18pt; color: white; font-family: sans-serif; margin: 10px">fa</div>
        </div>
        <div id="fsChart" style="padding: 10px 0px 10px 40px; left: 40%; width: 150; text-align: center; display: inline-block">
            <div style="font-size: 18pt; color: white; font-family: sans-serif; margin: 10px">fs</div>
        </div>
        <div id="woChart" style="padding: 10px 0px 10px 40px; left: 60%; width: 150; text-align: center; display: inline-block">
            <div style="font-size: 18pt; color: white; font-family: sans-serif; margin: 10px">wo</div>
        </div>
        <div id="massChart" style="padding: 10px 0px 10px 40px; left: 80%; width:150; text-align: center; display: inline-block">
            <div style="font-size: 18pt; color: white; font-family: sans-serif; margin: 10px">mass</div>
        </div>
        <div id="costChart" style="padding: 10px 0px 10px 40px; left: 80%; width:150; text-align: center; display: inline-block">
            <div style="font-size: 18pt; color: white; font-family: sans-serif; margin: 10px">$ value</div>
        </div>
		<!--
        <div id="subTypeChart" style="padding: 10px 0px 10px 40px; left: 80%; width:150; text-align: center; display: inline-block">
            <div style="font-size: 18pt; color: white; font-family: sans-serif; margin: 10px">Classification</div>
        </div>-->
    </div>


    <div id="UISwitches" style="position:absolute; z-index:4; bottom: 0px; left: 0px; width: 300px; height: 200px; padding: 14px 0px; box-sizing: border-box; text-align: center">
        <input id="search" type="search" placeholder="" style="margin: 10px auto; border: 0px; height: 30px; border-radius: 11px; width: 248px; padding: 4px; font-size: 18px" class="searchBlur" onfocus="searchFocus()" onblur="searchBlur()" oninput="filter(this.value)" />
        <div id="city" style="text-align: left; border-radius: 10px; color: white; background: steelblue url('close.svg') 222px center no-repeat; border: 1px solid white; height: 30px; font-size: 18px; font-family: sans-serif; padding: 4px 10px; box-sizing: border-box; width: 248px; margin: -5px auto 5px auto; overflow: hidden; white-space: nowrap; text-overflow: ellipsis; display: none" onclick="hideCity()">[PT] Lisbon</div>
        <img src="dotmap.svg" width="80" style="border-radius: 10px 0px 0px 10px; border: 1px solid #303030; margin: 1px; padding: 0px 20px; background: #303030" onclick="showHexbin(); this.style.border = '1px solid #999999'; this.nextSibling.style.border = '1px solid #303030'; meteoFilter.updateVis()" /><img src="choropleth_map.svg" width="80" style="border-radius: 0px 10px 10px 0px; border: 1px solid #999999; margin: 1px; padding: 0px 20px; background: #303030; " onclick="    hideHexbin(); this.style.border = '1px solid #999999'; this.previousSibling.style.border = '1px solid #303030'; meteoFilter.updateVis()" /><img src="charts.svg" width="80" style="border-radius: 10px 0px 0px 10px; border: 1px solid #303030; margin: 1px; padding: 0px 20px; background: #303030; " onclick="d3.select('#smallMultiples').style('display', 'block'); d3.select('#parallelChart').style('display', 'none'); this.style.border = '1px solid #999999'; this.nextSibling.style.border = '1px solid #303030';"/><img src="parallel_coordinates.svg" width="80" style="border-radius: 0px 10px 10px 0px; border: 1px solid #999999; margin: 1px; padding: 0px 20px; background: #303030" onclick="d3.select('#smallMultiples').style('display', 'none'); d3.select('#parallelChart').style('display', 'block'); this.style.border = '1px solid #999999'; this.previousSibling.style.border = '1px solid #303030';"/>
        <div id="what" style="position: absolute; overflow:hidden; top: 0px; height: 260px; width: 0px; left: 305px; padding: 4px 0px 4px 0px; z-index: 10; border-right: 5px solid white; background: #202020; display: none;"></div>
    </div>

    <div id="tip" class="d3-tip" style="opacity: 0; border-radius: 0px 0px 0px 0px; background: linear-gradient(to bottom, rgba(64,64,64,0.95) 10px, rgba(0,0,0,0.95) 40px); box-sizing: border-box; width: 200px; display: none; border: 2px #303030 solid; box-shadow: 2px 2px 5px rgba(0,0,0,0.5);">
        <div id="metName" style="font-size: 16pt; text-align: center; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;"></div>
        <div style="" id="star_chart"></div>
		<div id="otherInfo">
			<div id="metYear" style="text-align: right; width: 100%; font-size: 10pt; box-sizing: border-box; padding: 2px; margin-top: 8px; "></div>
            <div id="metYearC" style="text-align: right; width: 100%; height: 6px; box-sizing: border-box; margin: 2px 0px; border: 1px solid; border-color: #333 #666 #666 #333; "></div>
			<div id="metMass" style="text-align: right; width: 100%; font-size: 10pt; box-sizing: border-box; padding: 2px; margin-top: 8px; "></div>
            <div id="metMassC" style="text-align: right; width: 100%; height: 6px; box-sizing: border-box; margin: 2px 0px; border: 1px solid; border-color: #333 #666 #666 #333; "></div>
            <div id="metElevation" style="text-align: right; width: 100%; font-size: 10pt; box-sizing: border-box; padding: 4px; margin-top: 8px; "></div>
            <div id="metElevationC" style="text-align: right; width: 100%; height: 6px; box-sizing: border-box; margin: 2px 0px; border: 1px solid; border-color: #333 #666 #666 #333; "></div>
            <div id="metCost" style="text-align: right; width: 100%; font-size: 10pt; box-sizing: border-box; padding: 2px; margin-top: 8px; "></div>
            <div id="metCostC" style="text-align: right; width: 100%; height: 6px; box-sizing: border-box; margin: 2px 0px; "></div>
		</div>
	</div>

    <div style="position:absolute; width:200px; height: 101px; top: 10px; box-shadow: 2px 2px 10px #333; left: 10px; border: 2px solid white; z-index:2000; overflow:hidden; padding: -80px 0px 0px 0px; background: white url('worldmap.svg') 0 0 no-repeat; background-size: contain">        
		<div id="mapdetail" style="height:100%; border: 1px solid white; box-shadow: 2px 2px 10px #333; background: rgba(128,128,255,0.4)"></div>
    </div>

    <!-- SIDEBAR -->
    <div id="bg" style="position: absolute; top: 0; left: 0; width: 280px; height:100%; background: rgba(0,0,0,0.8); z-index:2; display:none">
        <!--<div id="star_chart" style="position: absolute; top: 130px; right: 10px; width: 248px; padding: 0px 0px; border: 0px solid #808080; border-radius: 10px; background: rgba(32,32,32,0.9); overflow: hidden; z-index: 1; box-shadow: rgba(255,255,255,0.1) -2px -2px"></div>-->
    </div>
    
    <!-- MAP -->
    <div id="map" style="position: absolute; top: 0px; left: 0px; width: 100%; height: 100%; padding: 0px; margin: 0px;"></div>
    <script>
        // Auxiliary functions

        // Grouping and Counting of the values in an array Index
        function groupAndCount(arr, index) {
            var a = [], b = [], prev;

            arr.sort(function (x, y) { return x[index] - y[index] });

            for (var i = 0; i < arr.length; i++) {
                if (arr[i][index] !== prev) {
                    a.push(new Array(arr[i][index], 1));
                    //b.push(1);
                } else {
                    a[a.length - 1][1]++;
                    //b[b.length - 1]++;
                }
                prev = arr[i][index];
            }

            var str = "";
            for (var i = 0; i < a.length; i++)
                str += a[i][0] + "\t" + a[i][1] + "\n";

            return a;

            //return [a, b];
        }

        function groupAndCountByYear(arr) {
            var x = [["2016", 0]];
            if (arr.length != 0)
                x = groupAndCount(arr, "year");
            /* else
                console.log(x[0]); */
            var j = 0;
            var z = parseInt(x[j][0]);
            var res = [];
            for (var i = 1877; i < 2016; i++) {

                if (i < z) res.push({ date: i, price: 0 });
                else
                    if (i == z) {
                        res.push({ date: z, price: x[j][1] });
                        j++;
                        if (j < x.length)
                            z = parseInt(x[j][0]);
                    }
            }
            res.push({ date: 2016, price: 0 });
            return res;
        }

        function filterLabeling() {
            var label = window.document.getElementById("filterLabel");
            if (meteoFilter.data.length == meteos.length)
                
                label.innerHTML = "Total Impacts on"
            else
                label.innerHTML = meteoFilter.data.length + " Impacts on"
        }

    </script>
    <script>
        // LOADING

        var cities,
            meteos,
            topology,
            countries,
            onlyonce = true,
            activeElement = 0;

        var parallelContainerHeight = 260,
            parallelContainerWidth = window.innerWidth-305;


        function addUp(d) {
            var x = d;
            if (d === "undefined") return 1;
            var ret = 1;
            switch (hexbinFilter.filter) {
                case 0: ret = 1; break;
                case 1: ret = x["fs"]; break;
                case 2: ret = x["fa"]; break;
                case 3: ret = x["wo"]; break;
                case 4: ret = x["mass"]; break;
                case 5: ret = x["cost"]; break;
                default: ret = 1;
            }
            if (onlyonce) {
                //console.log("original: " + x["fs"] + " | return: " + ret);
                onlyonce = false;
            }
            return ret;
        }

        var hexbinFilter = {
            filter: 1,
        }

        var choro = true; // choro decides whether the map shows a choropleth or the hex bin
                          // ignored during country focus

        var meteoFilter = {
            startYear: 1877,
            endYear: 2016,
            minLat: -180,
            maxLat: +180,
            minFa: 0,
            maxFa: 100,
            minFs: 0,
            maxFs: 100,
            minWo: 0,
            maxWo: 100,
            minMass: 0,
            maxMass: 100000000,
            minElevation: -20000,
            maxElevation: 20000,
            city: [],
            ct: 0,
            data: null,
            dataNoTime: null,
            changed: false,
            country: function (a) {
                if (typeof a !== "undefined") {
                    if (this.ct != a) {
                        activeElement = 0;
                        this.ct = a;
                        this.process();
                        this.changed = true;
                    }
                } else {
                    return this.ct;
                }
            },
            years: function (a, b) {
                var changed = false;
                if (typeof a !== "undefined") {
                    if (a != this.startYear) {
                        this.startYear = a;
                        changed = true;
                    }
                    if (typeof b !== "undefined") {
                        if (b != this.endYear) {
                            this.endYear = b;
                            changed = true;
                        }
                    } else {
                        this.endYear = startYear + 1;
                        changed = true;
                    }
                    if (changed){
                        this.process();
                        this.changed = true;
                    }
                } else {
                    return [this.startYear, this.endYear];
                }
            },
            latitude: function (a, b) {
                if (typeof a !== "undefined" && typeof b !== "undefined") {
                    this.minLat = a;
                    this.maxLat = b;
                    this.process();
                    this.changed = true;
                } else {
                    return [this.minLat, this.maxLat];
                }
            },
            fa: function (a, b) {
                if (typeof a !== "undefined" && typeof b !== "undefined") {
                    this.minFa = a;
                    this.maxFa = b;
                    this.process();
                    this.changed = true;
                } else {
                    return [this.minFa, this.maxFa];
                }
            },
            fs: function (a, b) {
                if (typeof a !== "undefined" && typeof b !== "undefined") {
                    this.minFs = a;
                    this.maxFs = b;
                    this.process();
                    this.changed = true;
                } else {
                    return [this.minFs, this.maxFs];
                }
            },
            wo: function (a, b) {
                if (typeof a !== "undefined" && typeof b !== "undefined") {
                    this.minWo = a;
                    this.maxWo = b;
                    this.process();
                    this.changed = true;
                } else {
                    return [this.minWo, this.maxWo];
                }
            },
            mass: function (a, b) {
                if (typeof a !== "undefined" && typeof b !== "undefined") {
                    this.minMass = a;
                    this.maxMass = b;
                    this.process();
                    this.changed = true;
                } else {
                    return [this.minMass, this.maxMass];
                }
            },
            elevation: function (a, b) {
                if (typeof a !== "undefined" && typeof b !== "undefined") {
                    this.minElevation = a;
                    this.maxElevation = b;
                    this.process();
                    this.changed = true;
                } else {
                    return [this.minElevation, this.maxElevation];
                }
            },
            process: function (a) {
                
                var sy = this.startYear,
                    ey = this.endYear,
                    ml = this.minLat,
                    xl = this.maxLat,
                    ct = this.ct,
                    mnFa = this.minFa,
                    mxFa = this.maxFa,
                    mnFs = this.minFs,
                    mxFs = this.maxFs,
                    mnWo = this.minWo,
                    mxWo = this.maxWo,
                    mnMa = this.minMass,
                    mxMa = this.maxMass,
                    mnEl = this.minElevation,
                    mxEl = this.maxElevation,
                    operation = 0;

                if (a !== "undefined")
                    operation = a;

                tmp = meteos;
                if (ct != 0) tmp = meteos.filter(function (d) { return ct == d.cid; });
                
                this.data = tmp.filter(function (d) {
                    return d.year >= sy
                        && d.year <= ey
                        && d.fa >= mnFa
                        && d.fa <= mxFa
                        && d.fs >= mnFs
                        && d.fs <= mxFs
                        && d.wo >= mnWo
                        && d.wo <= mxWo
                        && d.mass >= mnMa
                        && d.mass <= mxMa
                        && d.elevation >= mnEl
                        && d.elevation <= mxEl
                })

                this.dataNoTime = tmp.filter(function (d) {
                    return d.fa >= mnFa
                        && d.fa <= mxFa
                        && d.fs >= mnFs
                        && d.fs <= mxFs
                        && d.wo >= mnWo
                        && d.wo <= mxWo
                        && d.mass >= mnMa
                        && d.mass <= mxMa
                        && d.elevation >= mnEl
                        && d.elevation <= mxEl
                })

            },
            updateVis: function (){
                if (runOnce) {
                    if (typeof this.city.latitude !== "undefined") {
                        displayCity();
                    }
                    adjustHexBin();
                    if (this.changed) {
                        if (activeElement != 1)
                            adjustTimeline();
                        //if (a != 2) barChartRedraw();
                        //if (a != 3) starChartRedraw();
                        if (activeElement != 4)
                            parallelRedraw();
                    }
                    updateHistogram("mass")
                    updateHistogram("elevation")
                    updateHistogram("fa")
                    updateHistogram("fs")
                    updateHistogram("wo")
                    updateHistogram("cost")


					
                    choropleth();
                    filterLabeling();
                    this.changed = false;
                }
            },
            yearSeries: function () {
                var ct = this.ct;
                return meteos.filter(function (d) { var country = (ct != 0) ? d.cid == ct : true; return country; })
            }

        }

        var meteosByYear;

        function initVis(error, csvCity) {
            meteoFilter.process();
            meteosByYear = groupAndCountByYear(meteoFilter.yearSeries());
            initParallel();
            makeChart();
            //initBarChart();
            genHistogram("mass", [0.1, 1, 10, 100, 1000, 10000, 100000, 1000000, 10000000], "#massChart")
            genHistogram("elevation", [0, 10, 50, 100, 200, 500, 1000, 2000, 5000], "#elevationChart")
            genHistogram("fa", [0, 12.5, 25, 37.5, 50, 62.5, 75, 87.5, 100], "#faChart")
            genHistogram("fs", [0, 12.5, 25, 37.5, 50, 62.5, 75, 87.5, 100], "#fsChart")
            genHistogram("wo", [0, 12.5, 25, 37.5, 50, 62.5, 75, 87.5, 100], "#woChart")
            genHistogram("cost", [0, 10, 50, 100, 500, 1000, 5000, 10000, 50000], "#costChart")
            //genHistogram("subtype", [0, 10, 50, 100, 500, 1000, 5000, 10000, 50000], "#subTypeChart")
            initStarChart();
            updateChoroLegend();
            

            loadworld();
            window.setTimeout(reset, 10);

            var allfeatures = svg.selectAll(".feature")[0];
            for (var i = 0; i < allfeatures.length; i++) {
                if (allfeatures[i].id == 10) allfeatures[i].style.display = "none";
            }

            window.document.getElementById("bg").style.height = (window.innerHeight - window.document.getElementById("chart").offsetHeight) + "px";
            window.document.getElementById("chart").style.bottom = window.document.getElementById("parallelChart").offsetHeight + 5;
            //window.document.getElementById("countryLabel").style.top = window.document.getElementById("chart").offsetTop;
            window.document.getElementById("filterLabel").style.bottom = window.innerHeight - window.document.getElementById("chart").offsetTop;
            window.document.getElementById("filterLabel").style.display = "block";
            window.document.getElementById("sample").style.bottom = window.document.getElementById("parallelChart").offsetHeight + 7;
            window.document.getElementById("sample2").style.bottom = window.document.getElementById("parallelChart").offsetHeight + 7;
            window.document.getElementById("UISwitches").style.height = window.document.getElementById("parallelChart").offsetHeight;

            window.document.getElementById("smallMultiples").style.height = parallelContainerHeight + "px";
            //window.document.getElementById("smallMultiples").style.width = parallelContainerWidth + "px";
            window.document.getElementById("smallMultiples").style.bottom = "0px";
            window.document.getElementById("smallMultiples").style.backgroundColor = "rgba(18,18,18,0.95)";

            runOnce = true;
            //setInterval(meteoFilter.updateVis,200)
            d3.select("body").on("mousemove", function () {
                var pt = d3.mouse(this),
                    el = window.document.getElementById("tip");
                var x = ((pt[0] + el.offsetWidth + 20) > window.innerWidth) ? pt[0] - el.offsetWidth - 20 : pt[0] + 20,
                    y = ((pt[1] + el.offsetHeight - 20) > window.innerHeight) ? window.innerHeight - el.offsetHeight : pt[1] - 20;
                d3.select("#tip")
                    .style("left", x)
                    .style("top", y)
                //console.log(document.elementFromPoint(pt[0], pt[1]).parentElement.getAttribute("class"))
            })

            

			console.log(meteos)
        }
    </script>
    <script>
        // SEARCHING

        function filter(string) {
            // CLEAR PREVIOUS RESULTS
            var myNode = document.getElementById("what");
            while (myNode.firstChild) {
                myNode.removeChild(myNode.firstChild);
            }

            // CHECK IF SEARCH BOX IS EMPTY
            if (isEmpty(string)) {
                myNode.style.display = "none";
                return;
            } else {
                myNode.style.display = "block";
            }

			var arr = string.split(" ")
			if (arr.length > 1){
				var x = parseFloat(arr[0]),
					y = parseFloat(arr[1]);
				if (!isNaN(x) && !isNaN(y)) {
					meteoFilter.city = { name: "Your Location", latitude: x, longitude: y}
					var city = window.document.getElementById("city"),
                        input = window.document.getElementById("search")

                    city.style.display = "block";
                    city.innerText = x+", "+y;

                    d3.select("#what")
                        .transition()
                        .duration(250)
                        .style("width", "0")
                        .delay(300)
                        .each("end", function (d) { this.style.display = "none" })
						
					displayCity()
					return;
				}
			}
			
            // PREPROCESS RESULTS

            var counterCities = 0;
            var counterMeteos = 0;

            var selectedCities = cities.filter(function (d) { return d.name.toLowerCase().indexOf(string.toLowerCase()) > -1; });
            var selectedMeteos = meteos.filter(function (d) { return d.name.toLowerCase().indexOf(string.toLowerCase()) > -1; });

            var subSelectionCities = selectedCities;

            var subSelectionMeteos = selectedMeteos;

            if (selectedCities.length + selectedMeteos.length > 21) {
                if (selectedCities.length > 6)
                    subSelectionCities = selectedCities.slice(0, 6);

                if (selectedMeteos.length > 6)
                    subSelectionMeteos = selectedMeteos.slice(0, 6);
            }


            // INSERT NEW RESULTS INTO THE PAGE

            var selection1 = d3.select("#what")
                .selectAll("div")
                .data(subSelectionCities);

            var selection2 = d3.select("#what")
                .selectAll("div")
                .data(subSelectionMeteos.slice(0));

            selection1.enter()
                .append("div")
                .attr("class", "searchResultCity")
                .attr("city", function (d) { return d.id; })
                .text(function (d) { counterCities++; return /* counterCities + */ "" + d.country + " - " + d.name; })
                .on("click", function (d) {
/*                    var e = document.createEvent('UIEvents');
                    e.initUIEvent('click', true, true, window, 1);

                    g.selectAll(".feature").each(function (h) {
                        if (this.id == d.cid)
                            if (active.node() != null) {
                                if (parseInt(active.node().id) != d.cid)
                                    this.dispatchEvent(e);
                            } else {
                                this.dispatchEvent(e);
                            }
                    })*/
                    var city = window.document.getElementById("city"),
                        input = window.document.getElementById("search")

                    city.style.display = "block";
                    city.innerText = this.innerText;

                    d3.select("#what")
                        .transition()
                        .duration(250)
                        .style("width", "0")
                        .delay(300)
                        .each("end", function (d) { this.style.display = "none" })

                    var x = d.id;
                    displayCity(x);
                });
            selection1.exit();

            if (subSelectionCities.length < selectedCities.length) {
                el = window.document.createElement("div");
                el.innerText = "and " + selectedCities.length + " more...";
                el.className = "and";
                window.document.getElementById("what").appendChild(el);
            }
            
            //selection2.enter()
            //    .append("div")
            //    .attr("class", "searchResultMeteo")
            //    .text(function (d) { counterMeteos++; return /* counterMeteos + " " + */ d.name; })
            //    .on("click", function (d) {
            //        var e = document.createEvent('UIEvents');
            //        e.initUIEvent('click', true, true, window, 1);

            //        g.selectAll(".feature").each(function (h) {
            //            if (this.id == d.cid) {
            //                if (active.node() != null) {
            //                    if (parseInt(active.node().id) != d.cid)
            //                        this.dispatchEvent(e);
            //                } else {
            //                    this.dispatchEvent(e);
            //                }
            //            }
            //        })

            //    })
            //selection2.exit();

            //if (subSelectionMeteos.length < selectedMeteos.length) {
            //    el = window.document.createElement("div");
            //    el.innerText = "and " + selectedMeteos.length + " more...";
            //    el.className = "and";
            //    window.document.getElementById("what").appendChild(el);
            //}

            d3.select("#what")
            .transition()
            .duration(250)
            .style("width", "200");
        }
    
        function hideCity() {
            window.document.getElementById("search").value = "";
            searchBlur();
            window.document.getElementById("city").style.display = "none";
            meteoFilter.city = [];
            g.selectAll("circle").remove();
            g.selectAll("line").remove();
            g.selectAll("text").remove();
        }

        function displayCity(a) {
            if (typeof a !== "undefined") {
                var ll = cities.filter(function (d) { return d.id == a })[0]
                meteoFilter.city = ll;
            } else {
                console.log("called")
                var ll = meteoFilter.city;
                if (ll.length == 0) return; // no city selected, coordinates array is empty
                console.log("still in here",ll)
            }
			
            var b = [ll.longitude, ll.latitude]

            var la = ll.latitude,
                lo = ll.longitude;

            g.selectAll("circle").remove();
            g.selectAll("line").remove();
            g.selectAll("text").remove();

            var x = mapCurrentScale;
            var delta = 160 / x;
            var dash = 10 / x;
            var numdiv = 9;
            for (var i = 0; i < numdiv; i++) {
                g.append("circle")
                    .attr("cx", mapProjection(b)[0])
                    .attr("cy", mapProjection(b)[1])
                    .attr("r", delta*i)
                    .attr("opacity", "0.5")
                    .attr("fill", "none")
                    .attr("stroke", "#303030")
                    .attr("stroke-dasharray", dash+","+dash)
            }
            for (var i = 0; i < numdiv-1; i++) {
                g.append("line")
                    .attr("x1", mapProjection(b)[0] + delta * i)
                    .attr("y1", mapProjection(b)[1])
                    .attr("x2", mapProjection(b)[0] + delta * (i+1))
                    .attr("y2", mapProjection(b)[1])
                    .attr("opacity", "0.5")
                    .attr("stroke-width", 1 / mapCurrentScale)
                    .attr("stroke","black")
            }

            g.append("text")
                .attr("x", mapProjection(b)[0])
                .attr("y", mapProjection(b)[1] - 4 / mapCurrentScale)
                .text("" + ll.name)
                .attr("fill", "black")
                .attr("text-anchor", "middle")
                .attr("opacity",1/mapCurrentScale)
                .attr("font-size", 32 / mapCurrentScale + "px")
                .style("font-family", "sans-serif")


            for (var i = 0; i < numdiv - 1; i++) {
                g.append("text")
                    .attr("x", mapProjection(b)[0] + delta * (i + 1) + 4 / mapCurrentScale)
                    .attr("y", mapProjection(b)[1] - 4/mapCurrentScale)
                    .text("" + Math.floor(5205 / mapCurrentScale) * (i + 1) + "km")
                    .attr("stroke-width", 1.5 / mapCurrentScale)
                    .attr("stroke", "white")
                    .attr("fill", "black")
                    .attr("font-size", 18 / mapCurrentScale + "px")
                    .style("font-family","sans-serif")
                g.append("text")
                    .attr("x", mapProjection(b)[0] + delta * (i + 1) + 4 / mapCurrentScale)
                    .attr("y", mapProjection(b)[1] - 4 / mapCurrentScale)
                    .text("" + Math.floor(5205 / mapCurrentScale) * (i + 1) + "km")
                    .attr("fill", "black")
                    .attr("font-size", 18 / mapCurrentScale + "px")
                    .style("font-family", "sans-serif")
            }
        }
    </script>
    <script>

        var chartMargin = { top: 85, right: 0, bottom: 0, left: 0 },
            chartMargin2 = { top: 40, right: 20, bottom: 0, left: window.innerWidth/3 - 10 },
            chartWidth = 240,
            chartWidth2 = window.innerWidth * 6/9,
            chartHeight = 170,
            chartHeight2 = 60;

        //console.log("width", window.innerWidth);
        var parseDate = d3.time.format("%b %Y").parse;

        var chartX = d3.scale.linear().range([0, chartWidth]),
            chartX2 = d3.scale.linear().range([0, chartWidth2]),
            chartY = d3.scale.linear().range([chartHeight, 0]),
            chartY2 = d3.scale.pow().exponent(.4).range([chartHeight2, 0.5]);

        var chartXAxis = d3.svg.axis().ticks(2).scale(chartX).orient("bottom"),
            chartXAxis2 = d3.svg.axis().scale(chartX2).ticks(8).tickSize(chartHeight).orient("top"),
            chartYAxis = d3.svg.axis().scale(chartY).ticks(4).tickSize(chartWidth).orient("right");

        var chartBrush = d3.svg.brush()
            .x(chartX2)
            .on("brush", chartBrushed)
            //.on("brush.tip",parallelTip)
            //.on("brushend",meteoFilter.updateVis)

        var chartArea = d3.svg.area()
            .interpolate("monotone")
            .x(function (d) { return chartX(d.date); })
            .y0(chartHeight)
            .y1(function (d) { return chartY(d.price); });

        var chartArea2 = d3.svg.area()
            .interpolate("monotone")
            .x(function (d) { return chartX2(d.date); })
            .y0(chartHeight2)
            .y1(function (d) { return chartY2(d.price); });

        var chartDiv = window.document.getElementById("chart");
        chartDiv.style.width = window.innerWidth + "px";
        chartDiv.style.left = 0 + "px";
        chartDiv.style.height = "100px";
        chartDiv.style.bottom = 221 + "px"

        var chartDiv2 = window.document.getElementById("chart2");
        chartDiv2.style.bottom = (chartHeight2 + chartMargin2.top + 10) + "px";

        var chartDiv3 = window.document.getElementById("visbar");
        chartDiv3.style.width = (window.innerWidth / 2) + "px";
        chartDiv3.style.left = 0 + "px";
        chartDiv3.style.height = (chartHeight2 + 40)+ "px";

        var chartSvg = d3.select("#chart").append("svg")
            .attr("width", window.innerWidth)
            .attr("height", (chartHeight2 + 50) + "px" );

        var chartSvg2 = d3.select("#chart2").append("svg")
            .attr("width", chartWidth + chartMargin.left + chartMargin.right)
            .attr("height", 254);

        var chartlabel = chartSvg.append("text")
            .attr("x", 5)
            .attr("y", 15) 
            .attr("font-size", 14)
            .text("Total/Year : ")
            .style("display","none");

        var focus = chartSvg2.append("g")
            .attr("class", "focus")
            .attr("transform", "translate(0,15)");

        var context = chartSvg.append("g")
            .attr("class", "context")
            .attr("transform", "translate(" + chartMargin2.left + "," + chartMargin2.top + ")");

        var zoom = d3.behavior.zoom()
            .x(chartX)
            .scaleExtent([1, 20])
            .on("zoom", draw);
        // Add rect cover the zoomed graph and attach zoom event.
        var rect = chartSvg2.append("svg:rect")
            .attr("class", "pane")
            .attr("width", chartWidth)
            .attr("height", chartHeight)
            .attr("transform", "translate(" + chartMargin.left + "," + chartMargin.top + ")")
            .call(zoom);

        var the_data;

        function makeChart() {
            data = groupAndCountByYear(meteoFilter.dataNoTime)
            //console.log(data);

            chartX.domain(d3.extent(data.map(function (d) { return d.date; })));
            chartY.domain([0, d3.max(data.map(function (d) { return d.price; }))]);
            chartX2.domain(d3.extent(data.map(function (d) { return d.date; })));
            chartY2.domain([0, d3.max(data.map(function (d) { return d.price; }))]);

            chartlabel.text("Total / Year : " + Math.min.apply(Math, chartX.domain()) + " - " + Math.max.apply(Math, chartX.domain()));

            // Set up zoom behavior
            zoom.x(chartX);

            focus.selectAll("path").remove();
            focus.selectAll("g").remove();
            context.selectAll("path").remove();
            context.selectAll("g").remove();

            focus.append("path")
                .datum(data)
                .attr("class", "area")
                .attr("d", chartArea);

            focus.append("g")
                .attr("class", "x axis")
                .attr("transform", "translate(0," + chartHeight + ")")
                .call(chartXAxis);

            var gy = focus.append("g")
                .attr("class", "y axis")
                .call(chartYAxis);

            gy.selectAll("g").filter(function (d) { return d; })
                .classed("minor", true);
            gy.selectAll("text")
                .attr("x", 4)
                .attr("dy", -4);
            gy.selectAll("path").attr("display", "none");

            context.append("path")
                .datum(data)
                .attr("d", chartArea2)
                .style("stroke","#999")
                .style("fill","none")

            context.append("path")
                .datum(data)
                .attr("class", "area")
                .attr("d", chartArea2);

            context.append("g")
                .attr("class", "x axis")
                .attr("transform", "translate(0," + (chartHeight2 + 1) + ")")
                .call(chartXAxis2);


            context.append("g")
                .attr("class", "x brush")
                .call(chartBrush)
                .selectAll("rect")
                .attr("y", 0 - chartMargin2.top)
                .attr("height", chartHeight2 + chartMargin2.top);

            context.selectAll("text").attr("y", 0 - chartHeight2 - chartMargin2.top + 20);
            context.selectAll("text").attr("x", 40);

            the_data = data.slice(0);
            //chartBrushed();
        }

        function adjustTimeline() {
            data = groupAndCountByYear(meteoFilter.dataNoTime)
            context.select(".area")
                .datum(data)
                .transition()
                .duration(725)
                .attr("d", chartArea2);
        }

        function adjustYAxis(a) {
            var min = d3.min(a);
            var max = d3.max(a);
            if (isNaN(min)) min = 1876;
            if (isNaN(max)) max = 2017;
            var filteredDates = data.filter(function (d) { return d.date > Math.floor(min) && d.date < Math.floor(max); });
            if (filter.length > 0)
                var mx = Math.max(4, d3.max(data.filter(function (d) { return d.date > Math.floor(min) && d.date < Math.floor(max); }).map(function (d) { return d.price; })));
            else
                var mx = 2;
            // adjusting
            chartY.domain([0, mx]);
            focus.select(".y.axis").call(chartYAxis);
            focus.select(".y.axis").selectAll(".tick").classed("minor", true);
            focus.select(".y.axis").selectAll(".tick").selectAll("text").attr("x", 4).attr("dy", -4);
            // setting chart label
            chartlabel.text("Total / Year : " + Math.floor(Math.min.apply(Math, a)) + " - " + Math.floor(Math.max.apply(Math, a)));
            
            //meteoFilter.years(Math.floor(Math.min.apply(Math, a)), Math.floor(Math.max.apply(Math, a)));
            
            adjustTimeline();
        }

        function chartBrushed() {
            console.log("I got called for reasons");
            activeElement = 1;

            var extent0 = chartBrush.extent(),
                extent1;
            console.log(chartBrush.extent())

            if (d3.event.mode === "move") {
                var d0 = Math.round(extent0[0]),
                    d1 = Math.round(extent0[1]);
                extent1 = [d0, d1];
            }

                // otherwise, if resizing, round both dates
            else {
                extent1 = extent0.map(Math.round);

                // if empty when rounded, use floor & ceil instead
                if (extent1[0] > extent1[1]) {
                    extent1[0] = Math.floor(extent0[0]);
                    extent1[1] = Math.ceil(extent0[1]);
                }
            }

            d3.select(this).call(chartBrush.extent(extent1));

            chartX.domain(chartBrush.empty() ? d3.extent(the_data.map(function (d) { return d.date; })) : chartBrush.extent());
            focus.select(".area").attr("d", chartArea);
            focus.select(".x.axis").call(chartXAxis);

            // Reset zoom scale's domain
            //adjustYAxis(chartX.domain());
            //zoom.x(chartX);

            var x = d3.select("#chart").selectAll(".extent").node();

            if (x !== "undefined" && parseInt(x.getAttribute("width")) > 0) {
                var l = parseInt(x.getAttribute("x")) + parseInt(x.getAttribute("width")) / 2 - window.document.getElementById("chart2").offsetWidth / 2;

                if (((l + window.innerWidth / 2) + window.document.getElementById("chart2").offsetWidth + 10) > window.innerWidth) l = window.innerWidth / 2 - window.document.getElementById("chart2").offsetWidth - 10;
                if (l < 10) l = 10;
                window.document.getElementById("chart2").style.left = (window.innerWidth / 2 + l) + "px";
                window.document.getElementById("chart2").style.display = "none" //"block";
            } else {
                window.document.getElementById("chart2").style.display = "none";
            }

            // Hack for when a brush is deleted
            // to properly reset the Y scale 
            if (chartBrush.empty()) {
                focus.select(".area").attr("d", chartArea);
            }

            meteoFilter.years(chartX.domain()[0], chartX.domain()[1]);

            meteoFilter.updateVis();
        }

        function draw() {
            focus.select(".area").attr("d", chartArea);
            focus.select(".x.axis").call(chartXAxis);

            adjustYAxis(chartX.domain());

            // Force changing chartBrush range
            chartBrush.extent(chartX.domain());

            chartSvg.select(".brush").call(chartBrush);
        }

        function type(d) {
            d.date = +d.date;
            d.price = +d.price;
            return d;
        }

    </script>
    <script>
        var mapLeftMargin = 0, //window.innerWidth/4,
            mapBottomMargin = 0 ;

        var mapWidth = window.innerWidth - mapLeftMargin,
            mapHeight = window.innerHeight - mapBottomMargin,
            active = d3.select(null);

        var mapProjection = d3.geo.equirectangular()
            .scale(mapWidth / 6.2)
            .translate([mapWidth / 2, mapHeight / 2]);

        var mapColor = d3.scale.pow().exponent(0.355555)
            .domain([0, 3000])
            .range([0, 8]);

        var choroColor = d3.scale.pow().exponent(0.2)
            .domain([0, 3000])
            .range([1, 9])

        var choroScale = d3.scale.pow().exponent(0.2)
            .domain([3000, 0])
            .range([0, 360])

        var mapOpacity = d3.scale.linear()
            .domain([0, 3000])
            .range([0.6, 1.0]);

        var hexSize = d3.scale.linear()
            .domain([0, 3000])
            .range([3, 8]);

        var hexbinDisplay = false;

        var mapHexbin = d3.hexbin()
            .size([mapWidth, mapHeight])
            .radius(8);

        var mapRadius = d3.scale.sqrt()
            .domain([0, 12])
            .range([0, 8]);

        var mapZoom = d3.behavior.zoom()
            .translate([0, 0])
            .scale(1)
            .scaleExtent([1, 400])
            .on("zoom", zoomed);

        var mapCountryArray = null;

        var path = d3.geo.path()
            .projection(mapProjection);

        window.document.getElementById("map").style.left = mapLeftMargin + "px";
        window.document.getElementById("map").style.width = mapWidth + "px";

        var svg = d3.select("#map").append("svg")
            .attr("width", mapWidth)
            .attr("height", mapHeight)
            .on("click", stopped, true);

        svg.append("rect")
            .attr("class", "background")
            .attr("width", mapWidth)
            .attr("height", mapHeight)
            .on("click", reset);

        var g = svg.append("g");
        var circles = g.append("g");

        function loadworld() {
            g.selectAll("path")
                .data(topojson.feature(topology, topology.objects.countries).features)
                .enter()
                .append("path")
                .attr("d", path)
                .attr("id", function (d) { return d.id; })
                .attr("class", "feature")
                .on("click", clicked);

            g.append("path")
                .datum(topojson.mesh(topology, topology.objects.countries, function (a, b) { return a !== b; }))
                .attr("class", "mesh")
                .attr("d", path);

            meteos.forEach(function (d) {
                var p = mapProjection([d.latitude, d.longitude]);
                d[0] = p[0], d[1] = p[1];
                //d.date = parseDate(d.date);
            });

            var mh = mapHexbin(meteos);
            var mx = 0;
            mh.forEach(findmax)

            hexbinFilter.filter = 0;

            function findmax(element, i, arr) {
                var z = 0;
                for (var i = 0; i < element.length; i++) {
                    z += addUp(element[i]);
                }
                //var z = element.slice(0,element.length-5).reduce(function(a,b){return a.fs + b.fs});
                if (z > mx) mx = z;
            }

            //console.log("mx : " + mx);
            mapColor.domain([1, mx]);

            //console.log(colorbrewer.Blues[9][Math.round(mapColor(mx/2))])

            g.append("g")
                .attr("class", "hexagons")

            choropleth();
            hideHexbin();
            svg.call(mapZoom) // delete this line to disable free zooming
                .call(mapZoom.event);
        }

        var cts = g.selectAll(".feature");

        function choropleth() {

            var tmp = groupAndCount(meteoFilter.data, "cid");
            var mx = 0;
            var cts = g.selectAll(".feature");
            var ct = meteoFilter.ct;
            var duration = 400;

            if (mapCountryArray == null) {
                mapCountryArray = new Array()
                cts.each(function (d, i) { mapCountryArray[d.id] = 0 })
            }

            var z = mapCountryArray.slice(0);

            for (var i = 0; i < tmp.length; i++) {
                if (tmp[i][1] > mx) mx = tmp[i][1];
                z[(tmp[i][0])] = tmp[i][1];
            }
            
            choroColor.domain([0, mx * 2]);
            choroScale.domain([mx * 2, 0]);

            if (ct != 0) {
                hideLegend();
                cts.each(
                    function (d, i) {
                        if (parseInt(d.id) == ct) {
                            d3.select(this).transition().duration(duration).style("fill", "orange");
                        }
                        else {
                            d3.select(this).transition().duration(duration).style("fill", "#ccc");
                        }
                    })
            } else {
                if (choro) {
                    cts.each(
                            function (d, i) {
                                d3.select(this).style("fill", colorbrewer.Blues[9][Math.round(choroColor(z[d.id]))]);
                            });
                    updateChoroLegend()
                }
                else {
                    hideLegend();
                    cts.each(
                        function (d, i) {
                            d3.select(this).style("fill", "#ccc");
                        });
                }
            }
        }

        function clicked(d) {
            if (active.node() === this) return reset();
            active.classed("active", false);
            active = d3.select(this).classed("active", true);
            
            //showHexbin();

            meteoFilter.country(active[0][0].id);

            var countryName = countries.filter(function (d) { return d.cid == active[0][0].id; })[0].name;
            window.document.getElementById("countryLabel").innerText = countryName;
            var fontsize = "8vh"//Math.min(window.innerWidth / (3 * 20), 80) + "px";
            window.document.getElementById("countryLabel").style.fontSize = fontsize;
            window.document.getElementById("filterLabel").style.fontSize = fontsize;
            var bottom = window.document.getElementById("parallelChart").offsetHeight + 10 + window.document.getElementById("chart").offsetHeight + 40,
                bounds = path.bounds(d),
                dx = bounds[1][0] - bounds[0][0],
                dy = bounds[1][1] - bounds[0][1],
                x = (bounds[0][0] + bounds[1][0]) / 2,
                y = (bounds[0][1] + bounds[1][1]) / 2,
                scale = .9 / Math.max(dx / mapWidth, dy / (mapHeight-bottom)),
                translate = [mapWidth / 2 - scale * x, (mapHeight - bottom) / 2 - scale * y];

            

            if (mapCurrentScale != scale)
                svg.transition()
                    .duration(750)
                    .call(mapZoom.scale(scale).translate(translate).event)
            else
                svg.transition()
                    .duration(750)
                    .call(mapZoom.translate(translate).event)
            meteoFilter.updateVis();
        }

        var mapDefaultTranslation = [0, 0],
            mapDefaultScale = 1;

        function reset() {
            active.classed("active", false);
            active = d3.select(null);
            meteoFilter.country(0);
            window.document.getElementById("countryLabel").style.fontSize = "5vw";
            window.document.getElementById("countryLabel").innerText = "the world";

            var bounds = g.node().getBBox(),
                dx = bounds.width,
                dy = bounds.height,
                x = (2*bounds.x + bounds.width) / 2,
                y = (2*bounds.y + bounds.height) / 2,
                scale =  0.9 * mapHeight / dy,
                translate = [mapWidth / 2 - scale * x, mapHeight / 2 - scale * y];

            mapCurrentScale = scale;
            mapCurrentTranslation = translate;

            //console.log("bounds", bounds);
            //console.log("translate", translate);
            //console.log("scale", scale);

            // if (mapCurrentScale != 1)
            svg.transition()
                .duration(750)
                .call(mapZoom.translate(translate).scale(scale).event);
            //else
            //    svg.transition()
            //        .duration(750)
            //        .call(mapZoom.translate([0, 0]).event);
            activeElement = 0;
            meteoFilter.updateVis();
        }

        var mapCurrentScale = 1;
        var mapCurrentTranslation = [0, 0];

        function zoomed() {

            g.style("stroke-width", 1.5 / d3.event.scale + "px");
            g.attr("transform", "translate(" + d3.event.translate + ")scale(" + d3.event.scale + ")");
			
			
            mapCurrentTranslation = d3.event.translate;
            //console.log(mapCurrentScale);
            // Only redraw the hexbin if the user has actually zoomed, not panned.
            if (d3.event.scale != mapCurrentScale) {
                mapCurrentScale = d3.event.scale;
                //adjustHexBin();
            }
			
			mapW = window.innerWidth * mapCurrentScale;
			mapH = window.innerHeight * mapCurrentScale;
			
			console.log(mapCurrentScale)
			
			
			window.document.getElementById("mapdetail").style.width = 200 * window.innerWidth / mapW;
			window.document.getElementById("mapdetail").style.height = 101 * window.innerHeight / mapH;
			window.document.getElementById("mapdetail").style.marginLeft = - 200 * mapCurrentTranslation[0] / mapW - 6;
			window.document.getElementById("mapdetail").style.marginTop = - 101 * mapCurrentTranslation[1] / mapH - 6;

            meteoFilter.updateVis();
            //console.log(mapCurrentScale)
        }

        d3.selection.prototype.size = function () {
            var n = 0;
            this.each(function () { ++n; });
            return n;
        };

        function showHexbin() {
            if (meteoFilter.ct != 0) return
            choro = false;
            hexbinDisplay = true;
            //d3.selectAll(".hexagons").style("display","block");
        }

        function hideHexbin() {
            if (meteoFilter.ct != 0) return
            choro = true;
            hexbinDisplay = false;
            //d3.selectAll(".hexagons").style("display","none");
        }

        var latmin,
            latmax

        function adjustHexBin(d) {
            if (meteoFilter.ct==0 && !hexbinDisplay) {
                d3.select(".hexagons").selectAll("path").remove(); return;
            }
            var tr = mapCurrentTranslation;

            // visible latitude boundaries
            latmin = mapProjection.invert([-tr[0] / mapCurrentScale, 0])[0];
            latmax = mapProjection.invert([(-tr[0] + mapWidth) / mapCurrentScale, 0])[0];

            var size = 8;
            var mh = /* (typeof d === "undefined") ? */ mapHexbin(meteos) /* : mapHexbin(meteos) */;
            var mx = 0;
            mh.forEach(function (element, i, arr) {
                var z = 0;
                for (var i = 0; i < element.length; i++) {
                    z += addUp(element[i]);
                }
                if (z > mx) mx = z;
            })

            hexbinFilter.filter = 0;

            mapColor.domain([1, mx * 2]);

            // adjust hexbin range and scale
            hexSize.range([size / mapCurrentScale, size / mapCurrentScale]);
            mapHexbin.radius(size / mapCurrentScale);
            //console.log(mapCurrentScale)
            // update the global filter
            meteoFilter.latitude(latmin, latmax);

            data = (typeof d === "undefined") ? 
                mapHexbin(meteoFilter.data.filter(function (d) { return d.latitude > latmin && d.latitude < latmax; })).sort(function (a, b) { return b.length - a.length; }).filter(function (d) { return d.length > 0; }) : 
                mapHexbin(d.filter(function (d) { return d.latitude > latmin && d.latitude < latmax; })).sort(function (a, b) { return b.length - a.length; }).filter(function (d) { return d.length > 0; } );
            //svg.select(".hexagons").selectAll("path").length;
            // redraw hexbin
            d3.select(".hexagons")
            .selectAll("path")
            .each(function (d, i) {
                if (data.length > 0) {
                    var g = data.shift();
                    var str = mapHexbin.hexagon(hexSize(g.length));
                    var res = "";
                    var commands = str.split(/(?=[lmz])/);
					var num = g.length;
					var metName = g[0].name;
					var metYear = g[0].year;
					var metElevation = g[0].elevation;
					var metFa = g[0].fa;
					var metFs = g[0].fs;
					var metWo = g[0].wo;
					var metType = g[0].type;
					var metSubtype = g[0].subType;
					var metCost = g[0].cost;
					var metMass = g[0].mass;
					var gi = g.i;
					var gj = g.j;

                    for (var k = 0; k < commands.length; k++) {
                        if (k == 0) {
                            var pointArray = commands[k].slice(1).split(',');
                            pointArray[0] = +pointArray[0] + g.x;
                            pointArray[1] = +pointArray[1] + g.y;
                            res += commands[k].slice(0, 1) + pointArray[0] + "," + pointArray[1];
                        } else {
                            res += commands[k];
                        }
                    }

                    d3.select(this)
                        .attr("transform", "")
                        .attr("d", res)
                        .style("fill", colorbrewer.Blues[9][Math.round(mapColor(g.length)) * 2])
						.attr("i",gi)
						.attr("j",gj)
						.on("mouseover",function(d){
							clearTimeout(tipTimeout)
							if (parseInt(this.getAttribute("num")) > 1)
							    hexTip(this.getAttribute("i"), this.getAttribute("j"), this.getAttribute("num") + " meteorites");
							else
							    hexTip(this.getAttribute("i"), this.getAttribute("j"), this.getAttribute("name"), this.getAttribute("year"), this.getAttribute("mass"), this.getAttribute("cost"), this.getAttribute("type"), this.getAttribute("subtype"), this.getAttribute("fa"), this.getAttribute("fs"), this.getAttribute("wo"), this.getAttribute("elevation"))

							window.document.getElementById("tip").style.display = "block";

							d3.select("#tip")
                                .transition()
                                .duration(725)
                                .style("opacity", "1")

							//d3.select("#tip")
                            //    .transition()
                            //    .duration(100)
                            //    .style("left", this.getBoundingClientRect().left - 92)
                            //    .style("bottom", (window.innerHeight - this.getBoundingClientRect().top + 15))
                            //    .transition()
                            //    .duration(260)
                            //    .delay(100)
                            //    .style("opacity", "1")

						})
						.on("mouseout", function (d) {
						    tipTimeout = setTimeout(function () {
						        d3.select("#tip")
                                    .transition()
                                    .duration(725)
                                    .style("opacity", "0")
						    }, 300);
						    restoreParallel();
						});
				} else {
					d3.select(this).remove();
				
				}
            })
            while (data.length > 0) {
                var g = data.shift();
                var str = mapHexbin.hexagon(hexSize(g.length));
                var res = "";
				var num = g.length;
				var metName = g[0].name;
				var metYear = g[0].year;
				var metElevation = g[0].elevation;
				var metFa = g[0].fa;
				var metFs = g[0].fs;
				var metWo = g[0].wo;
				var metType = g[0].type;
				var metSubtype = g[0].subType;
				var metCost = g[0].cost;
				var metMass = g[0].mass;
				var gi = g.i;
				var gj = g.j;

				
                var commands = str.split(/(?=[lmz])/);
                for (var k = 0; k < commands.length; k++) {
                    if (k == 0) {
                        var pointArray = commands[k].slice(1).split(',');
                        pointArray[0] = +pointArray[0] + g.x;
                        pointArray[1] = +pointArray[1] + g.y;
                        res += commands[k].slice(0, 1) + pointArray[0] + "," + pointArray[1];
                    } else {
                        res += commands[k];
                    }
                }
				d3.select(".hexagons")
					.append("path")
					.attr("d", res)
					.style("fill", colorbrewer.Blues[9][Math.round(mapColor(g.length)) * 2])
					.style("stroke", "black")
					.attr("i",gi)
					.attr("j",gj)
					.on("mouseover",function(d){
						clearTimeout(tipTimeout)
						if (parseInt(this.getAttribute("num")) > 1)
						    hexTip(this.getAttribute("i"), this.getAttribute("j"), this.getAttribute("num") + " meteorites");
						else
						    hexTip(this.getAttribute("i"), this.getAttribute("j"), this.getAttribute("name"), this.getAttribute("year"), this.getAttribute("mass"), this.getAttribute("cost"), this.getAttribute("type"), this.getAttribute("subtype"), this.getAttribute("fa"), this.getAttribute("fs"), this.getAttribute("wo"), this.getAttribute("elevation"))

						window.document.getElementById("tip").style.display = "block";

					    d3.select("#tip")
                            .transition()
                            .duration(725)
                            .style("opacity", "1")

						/*window.document.getElementById("tip").style.left = this.getBoundingClientRect().left - 105
						window.document.getElementById("tip").style.bottom = window.innerHeight - this.getBoundingClientRect().top + 5*/

					})
					.on("mouseout", function (d) {
					    tipTimeout = setTimeout(function () {
					        d3.select("#tip")
                                .transition()
                                .duration(725)
                                .style("opacity", "0")
					    }, 300);
					    restoreParallel();
					});
            }
        }

        var choroLegend = svg.append("g")
                            .attr("id", "chorolegend");

        function hideLegend() {
            d3.select("#choroLegend")
                .selectAll("rect").remove();
            d3.select("#choroLegend")
                .selectAll("g").remove();
            d3.select("#choroLegend")
                .selectAll("text").remove();
        }

        function updateChoroLegend() {
            
            hideLegend();

            var size = 40;
            choroLegend.attr("transform","translate("+(window.innerWidth-size)+",0)")

            choroLegend.append("rect")
                .attr("x", -2)
                .attr("y", -2)
                .attr("width", size+4)
                .attr("height", 9*size+4)
                .style("fill", "black")

            for (var i = 0; i < 9; i++) {
                choroLegend.append("rect")
                    .attr("x", 0)
                    .attr("y", i * size)
                    .attr("width", size)
                    .attr("height", size)
                    .style("fill", colorbrewer.Blues[9][(9 - i - 1)])
                choroLegend.append("text")
                    .attr("x", -size/2)
                    .attr("y", i*size + 22)
                    .text(Math.round(choroScale.invert(i * 40)))
                    .attr("font-size","16pt")
                    .attr("text-anchor","end")
            }
        }
                            


        // If the drag behavior prevents the default click,
        // also stop propagation so we don’t click-to-zoom.
        function stopped() {
            if (d3.event.defaultPrevented) d3.event.stopPropagation();
        }
    </script>
    <script src="barChart.js"></script>
    <script src="starChart.js"></script>
    <script src="histogram.js"></script>
    <script type="text/javascript">

        function group(arr, index) {
            var a = [], b = [], prev;

            //arr.sort(function (x, y) { return x[index] - y[index] });

            for (var i = 0; i < arr.length; i++) {
                if (a.indexOf(arr[i][index]) == -1)
                    a.push(arr[i][index]);
                //prev = arr[i][index];
            }

            return a;
        }

        var parallelMargin = [40, 0, 10, 0],
            parallelWidth = parallelContainerWidth - parallelMargin[1] - parallelMargin[3],
            parallelHeight = parallelContainerHeight - parallelMargin[0] - parallelMargin[2];

        window.document.getElementById("parallelChart").style.height = parallelContainerHeight + "px";
        window.document.getElementById("parallelChart").style.backgroundColor = "rgba(18,18,18,0.95)";

        var parallelX = d3.scale.ordinal().rangePoints([0, parallelWidth], 1),
            parallelY = {};

        var parallelLine = d3.svg.line(),
            parallelAxis = d3.svg.axis().ticks(4).orient("left"),
            parallelBackground,
            parallelForeground,
            parallelCache;

            parallelCache = window.document.createElement("CANVAS");
            
            d3.selectAll(".parallelCanvas")
                .attr("width", parallelWidth + parallelMargin[1] + parallelMargin[3])
                .attr("height", parallelHeight + parallelMargin[0] + parallelMargin[2])
                .style("padding", parallelMargin.join("px ") + "px");

            parallelCache.setAttribute("width", parallelWidth + parallelMargin[1] + parallelMargin[3]);
            parallelCache.setAttribute("height", parallelHeight + parallelMargin[0] + parallelMargin[2]);

            parallelForeground = document.getElementById('parallelForeground').getContext('2d');
            parallelBackground = document.getElementById('parallelBackground').getContext('2d');
            

            parallelForeground.strokeStyle = "rgba(255,165,0,0.05)" //"rgba(0,100,160,0.24)";
            parallelBackground.strokeStyle = "rgba(128,128,128,0.01)";

            var parallelSVG = d3.select("#parallelSVG")
                .attr("width", parallelWidth + parallelMargin[1] + parallelMargin[3])
                .attr("height", parallelHeight + parallelMargin[0] + parallelMargin[2])
              .append("g")
                .attr("transform", "translate(" + parallelMargin[3] + "," + parallelMargin[0] + ")");
            

        /*                  name: d.Name, 
                            country: d.Country, 
                            year: d.Year, 
                            latitude: d.Latitude, 
                            longitude: d.Longitude, 
                            mass: parseFloat(d.Mass), 
                            type: d.Type, 
                            subtype: d.SubType, 
                            fa: parseFloat(d.Fa) + 0.1, fs: parseFloat(d.Fs) + 0.1, wo: parseFloat(d.Wo) + 0.1, cost: parseFloat(d.Value), cid: parseFloat(d.cid) }; })
        */
            var dimensions = new Array();
            var subtypeGroup = null;

            var foregroundStored = false;

            function backupParallel() {
                if (foregroundStored) return;
                var ctx = parallelCache.getContext('2d')
                ctx.clearRect(0, 0, 2000, 2000)
                ctx.drawImage(document.getElementById('parallelForeground'), 0, 0)
                foregroundStored = true;
            }

            function restoreParallel() {
                var ctx = document.getElementById('parallelForeground').getContext('2d')
                ctx.clearRect(0, 0, 2000, 2000)
                ctx.drawImage(parallelCache, 0, 0)
                foregroundStored = false;
            }

            function parallelRedraw(dataset) {
				
                document.getElementById('parallelForeground').getContext('2d').clearRect(0, 0, 2000, 2000);
                
                var dados = meteoFilter.data;
                if (typeof dataset !== "undefined")
                    dados = dataset;

                parallelForeground.strokeStyle = "rgba(255,165,0," + (0.6 - 0.55 * dados.length / meteos.length) + ")"
                if (dados.length < 10) parallelForeground.strokeStyle = "rgba(255,165,0, 0.95)"

                dados.map(function (p) {
                    parallelPath(p, parallelForeground);
                });
					
            }
                   
            function parallelDimensionLinear(d) {
                dimensions.push(d)
                return parallelY[d] = d3.scale.linear()
                                    .domain([d3.min(cars, function (p) { return +p[d]; }), d3.max(cars, function (p) { return +p[d]; })])
                                    .range([parallelHeight, 0.0])
            }

            function parallelDimensionLog(d) {
                dimensions.push(d)
                return parallelY[d] = d3.scale.log()
                                    .domain([Math.min(0.01, d3.min(cars, function (p) { return +p[d]; })), d3.max(cars, function (p) { return +p[d]; })])
                                    .range([parallelHeight, 0.0])
            }

            function parallelDimensionQuantitative(d) {
                dimensions.push(d)
                var x = group(cars, d)
                return parallelY[d] = d3.scale.ordinal()
                                    .domain(x)
                                    .rangeRoundBands([0, parallelHeight])

            }

            function initParallel() {
                cars = meteoFilter.data.slice(0);
                // Extract the list of dimensions and create a scale for each.
                
                //parallelDimensionQuantitative("subtype");
                parallelDimensionLinear("elevation");
                parallelDimensionLog("fa");
                parallelDimensionLog("fs");
                parallelDimensionLog("wo");
                parallelDimensionLog("mass");
                
                parallelX.domain(dimensions);

                //parallelX.domain(dimensions = d3.keys(cars[0]).filter(function (d) {

                //    if (/*d == "type" || */d == "subtype") {
                //        var x = group(cars, d)
                //        return parallelY[d] = d3.scale.ordinal()
                //        .domain(x)
                //        .rangeRoundBands([0, parallelHeight])
                //    } else
                //        if (d == "elevation") {
                //            return parallelY[d] = d3.scale.linear()
                //            .domain([d3.min(cars, function (p) { return +p[d]; }), d3.max(cars, function (p) { return +p[d]; })])
                //            .range([parallelHeight, 0.0])
                //        } else {
                //        return d != "name"
                //            && d != "country"
                //            && d != "year"
                //            && d != "latitude"
                //            && d != "longitude"
                //            && d != "class"
                //            && d != "cost"
                //            && d != "cid"
                //            && d != "type"
                //            && d != "subtype"
                //            && (parallelY[d] = d3.scale.log()
                //            .domain([Math.min(0.01, d3.min(cars, function (p) { return +p[d]; })), d3.max(cars, function (p) { return +p[d]; })])
                //            .range([parallelHeight, 0.0]))
                //    }

                //}));
                // Render full foreground and background

                var canvasWidth = parallelWidth + parallelMargin[1] + parallelMargin[3],
                    canvasHeight = parallelHeight + parallelMargin[0] + parallelMargin[2]

                var once = true;

                cars.map(function (d) {
                    parallelPath(d, parallelBackground);
                    parallelPath(d, parallelForeground);
                });

                // Add a group element for each dimension.
                var parallelG = parallelSVG.selectAll(".dimension")
                        .data(dimensions)
                        .enter().append("g")
                        .attr("class", "dimension")
                        .attr("transform", function (d) { return "translate(" + parallelX(d) + ")"; });

                // Add an axis and title.
                parallelG.append("g")
                    .attr("class", "axis")
                    .each(function (d) { d3.select(this).call(parallelAxis.scale(parallelY[d])); })
                    .append("text")
                    .attr("text-anchor", "middle")
                    .attr("y", -14)
                    .text(String);

                function parallelTip(d){ 
                    console.log("input : ",d);
                    if (this.parentElement.getAttribute("class") == "brush" || this.parentElement.parentElement.getAttribute("class") == "brush" || this.getAttribute("class") == "brush") {
                        var svg = this;
                        var rect = this;
                        while (svg.tagName.toLowerCase() != "svg") svg = svg.parentElement;
                        var pt  = svg.createSVGPoint();
                            
                        while (rect.getAttribute("class") != "brush") rect = rect.parentElement;
                        rect = rect.getElementsByClassName("extent")[0];
                        var corners = {};
                        var matrix  = rect.getScreenCTM();
                        pt.x = rect.x.animVal.value;
                        pt.y = rect.y.animVal.value;
                        corners.nw = pt.matrixTransform(matrix);
                        pt.x += rect.width.animVal.value;
                        corners.ne = pt.matrixTransform(matrix);
                        pt.y += rect.height.animVal.value;
                        corners.se = pt.matrixTransform(matrix);
                        pt.x -= rect.width.animVal.value;
                        corners.sw = pt.matrixTransform(matrix);

                        var left = Math.round(corners.nw.x);
                        var top = Math.round(corners.nw.y);
                        console.log(left,top);
                        //window.document.getElementById("tip").style.left = (left-105) + "px";
                        //window.document.getElementById("tip").style.bottom = (window.innerHeight - top + 20)+ "px";
                        window.document.getElementById("tip").style.display = "block";
                        console.log();
                        /*
                        parallelY[d].brush.extent()
                        parallelY[d].domain()[0], parallelY[d].domain()[1]
                        extents = parallelY[d].brush.extent();
                        */
                    }
                }


                // Add and store a brush for each axis.
                parallelG.append("g")
                    .attr("class", "brush")
                    .each(function (d) { d3.select(this).call(parallelY[d].brush = d3.svg.brush().y(parallelY[d]).on("brush", brush).on("brush.tip",parallelTip)); })
                    .selectAll("rect")
                    .attr("x", -8)
                    .attr("width", 16)
                    //.on("mouseover",parallelTip)

                    

                // Handles a brush event, toggling the display of foreground lines.
                function brush() {
                    activeElement = 4;
                    var actives = dimensions.filter(function (p) { return !parallelY[p].brush.empty(); }),
                        extents = actives.map(function (p) { return parallelY[p].brush.extent(); });

                    //var subTypeLength = parallelHeight / (2 * parallelY["subtype"].range().length);

                    // Get lines within extents
                    var selected = [];
                    cars.map(function (d) {
                        return actives.every(function (p, i) {
                            if (p == "type") {
                                return extents[i][0] <= (parallelY[p](d[p]) + typeLength) && (parallelY[p](d[p]) + typeLength) <= extents[i][1];
                            } else
                                if (p == "subtype") {
                                    return extents[i][0] <= (parallelY[p](d[p]) + subTypeLength) && (parallelY[p](d[p]) + subTypeLength) <= extents[i][1];
                                } else {
                                    return extents[i][0] <= d[p] && d[p] <= extents[i][1];
                                }
                                    
                        }) ? selected.push(d) : null;
                    });

                    // Render selected lines
                    parallelForeground.clearRect(0, 0, parallelWidth + 1, parallelHeight + 1);
                    selected.map(function (d) {
                        parallelPath(d, parallelForeground);                        
                    });

                    dimensions.filter(function (p) {
                        if (p == "subtype") return;
                        if (parallelY[p].brush.empty())
                            meteoFilter[p](parallelY[p].domain()[0], parallelY[p].domain()[1]);
                        else
                            meteoFilter[p](parallelY[p].brush.extent()[0], parallelY[p].brush.extent()[1]);
                    });
                    
                    meteoFilter.updateVis();
                    
                    parallelRedraw();
                    console.log(parallelForeground);
                }
            }

            function parallelPath(d, ctx) {
                //console.log(ctx);
                ctx.beginPath();
                var once = true;
                //var typeLength = parallelY["type"].range().length;
                //var subTypeLength = parallelY["subtype"].range().length;
                dimensions.map(function (p, i) {
                    if (i == 0) {
                        if (p == "type") {
                            ctx.moveTo(parallelX(p), parallelY[p](d[p]) + parallelHeight / (2 * typeLength));
                        } else
                            if (p == "subtype") {
                                ctx.moveTo(parallelX(p), parallelY[p](d[p]) + parallelHeight / (2 * subTypeLength));
                            } else
                                ctx.moveTo(parallelX(p), parallelY[p](d[p]));
                    } else {
                        if (p == "type") {
                            ctx.lineTo(parallelX(p), parallelY[p](d[p]) + parallelHeight / (2 * typeLength));
                        } else
                            if (p == "subtype") {
                                ctx.lineTo(parallelX(p), parallelY[p](d[p]) + parallelHeight / (2 * subTypeLength));
                            } else
                                ctx.lineTo(parallelX(p), parallelY[p](d[p]));
                    }
                });
                ctx.stroke();
            };

    </script>
    <script>

        function nozeroes(original, baseline) {
            if (original == 0)
                return baseline;
            else
                return original;
        }
        var meteoid = 0;
        queue()
            .defer(function (url, callback) {
                d3.tsv(url, function (error, result) {
                    cities = result;
                    //console.log(error, result);
                    callback(error, result);
                }).row(function (d) { return { id: d.geonameid, name: d.asciiname, latitude: d.latitude, longitude: d.longitude, country: d.cc, population: d.population, cid: d.id }; })
            }, "citiesclean.csv")
            .defer(function (url, callback) {
                d3.csv(url, function (error, result) {
                    meteos = result;
                    //console.log(error, result);
                    callback(error, result);
                }).row(function (d) { return { id: meteoid++, name: d.Name, country: d.Country, year: +d.Year, latitude: +d.Latitude, longitude: +d.Longitude, projectionlat: mapProjection([ +d.Latitude , +d.Longitude])[0],  projectionlon: mapProjection([+d.Latitude,+d.Longitude])[1], type: d.Type, subtype: d.SubType, elevation: nozeroes(parseFloat(d.Elevation),0.1), fa: parseFloat(d.Fa) + 0.1, fs: parseFloat(d.Fs) + 0.1, wo: parseFloat(d.Wo) + 0.1, cost: parseFloat(d.Value), mass: parseFloat(d.Mass), cid: parseFloat(d.cid) }; })
            }, "Meteo.csv")
            .defer(function (url, callback) {
                d3.csv(url, function (error, result) {
                    countries = result;
                    //console.log(error, result);
                    callback(error, result);
                }).row(function (d) { return { cid: d.id, name: d.name, code: d.code }; })
            }, "countryCodes.csv")
            .defer(function (url, callback) {
                d3.json(url, function (error, result) {
                    topology = result;
                    //console.log(error, result);
                    callback(error, result);
                })
            }, "world-110m.json")
            .await(initVis);
    </script>
</body>
</html>